object JTimerTask @java_type "java.util.TimerTask"
object JTimer @java_type "java.util.Timer"
thing TimerJava includes Timer @pim "Timer" @platform "java" {
	property timer : JTimer
	property timer_task : JTimerTask
	function startTimer(delay : Integer) do
		timer = `new java.util.Timer()`
	`java.util.TimerTask temp_task = new java.util.TimerTask(){public void run(){`
		timer!timer_timeout()
	`}};`
		timer_task = `temp_task`
		`` & timer & `.schedule(` & timer_task & `, ` & delay & `);`
	end
	function cancel() do
		if (not (timer_task == `null`)) do
			`` & timer_task & `.cancel();`
			`` & timer & `.purge();`
		end
	end
	statechart SoftTimer init default {
		state default {
			internal
			event m : timer?timer_start
			guard m.delay > 0
			action do
				startTimer(m.delay)
			end
			internal cancel
			event m : timer?timer_cancel
			action cancel()
		}
	}
}
thing fragment TimerMsgs {
	message timer_start(delay : Integer)
	message timer_cancel()
	@debug "false"
	message timer_timeout()
	message time(t : Long)
}
thing fragment Timer includes TimerMsgs {
	provided port timer {
		sends timer_timeout receives timer_start receives timer_cancel
	}
}
thing fragment TimerClient includes TimerMsgs {
	required port timer {
		sends timer_start sends timer_cancel receives timer_timeout
	}
}
thing TimerClientMock includes TimerClient @mock "true" {
}
thing PIM includes GeneralMsg , TemperatureMsg , OnOffMsg , TimerMsgs {
	provided port get_sensor {
		receives iamalive1 receives iamalive2 receives temperature
	}
	provided port human_input {
		receives SwitchOn receives SwitchOff receives set_temperature receives set_delta receives fetch_temp
	}
	required port human_output {
		sends temperature sends prompt
	}
	required port request_sensor {
		sends add_thermometer
	}
	required port request_actuator {
		sends add_device sends SwitchOn sends SwitchOff
	}
	required port guard_temperature {
		sends timer_start sends timer_cancel receives timer_timeout
	}
	required port guard_human {
		sends timer_start sends timer_cancel receives timer_timeout
	}
	property tmrature : Double = 20
	property thermo_id : Integer = 1
	property switch_id : Integer = 1
	property delta : Double = 0.1
	property lasttemp : Double = 0
	statechart PIM_behavior init Build {
		on entry do
			println ("Running The Room X3D2.MQTT.sim")
		end
		composite state Build init SetThermostat keeps history {
			on entry guard_human!timer_start(30000)
			on exit guard_human!timer_cancel()
			state SetThermostat {
				on entry do
					request_sensor!add_thermometer(thermo_id, "t")
					request_actuator!add_device(switch_id)
				end
				transition -> SetThermostat
				event human_input?SwitchOn
				action do
					human_output!prompt("Please set temperature for Thermostat")
				end
				transition -> SetThermostat
				event human_input?SwitchOff
				action do
					human_output!prompt("Please set temperature for Thermostat")
				end
			}
			internal
			event givedelta : human_input?set_delta
			action do
				delta = givedelta.dlta
			end
			internal
			event fetch : human_input?fetch_temp
			action do
				human_output!temperature(thermo_id, "temperature ", lasttemp)
			end
			internal
			event temp : get_sensor?temperature
			action do
				lasttemp = temp.t
			end
			internal
			event get_sensor?iamalive1
			action do
				human_output!prompt("INTERNAL ERROR: iamalive1 is covered inside Build")
			end
			internal
			event get_sensor?iamalive2
			action do
				human_output!prompt("INTERNAL ERROR: iamalive2 is covered inside Build")
			end
			transition -> Running
			event set_temp : human_input?set_temperature
			action do
				tmrature = set_temp.t
				human_output!prompt("Now entering thermostat. Please give temperature observations ")
			end
			transition -> Build
			event tmout : guard_human?timer_timeout
			action do
				human_output!prompt("Please continue doing the build of the temperature control")
			end
		}
		composite state Running init Thermostat keeps history {
			composite state Thermostat init TemprDecide {
				state TemprDecide {
					transition -> TemprDecrease guard lasttemp >= tmrature - delta
					action do
						request_actuator!SwitchOff(switch_id)
					end
					transition -> TemprIncrease guard lasttemp < tmrature - delta
					action do
						request_actuator!SwitchOn(switch_id)
					end
				}
				state TemprIncrease {
					on entry guard_temperature!timer_start(65000)
					on exit guard_temperature!timer_cancel()
					transition -> TemprIncrease
					event temp : get_sensor?temperature
					guard temp.t <= tmrature + delta
					action do
						if (lasttemp > temp.t) request_actuator!SwitchOn(switch_id)
						lasttemp = temp.t
					end
					transition -> TemprDecrease
					event temp2 : get_sensor?temperature
					guard temp2.t > tmrature + delta
					action do
						request_actuator!SwitchOff(switch_id)
						lasttemp = temp2.t
					end
					transition -> TemprIncrease
					event timout : guard_temperature?timer_timeout
					action do
						human_output!prompt("WARNING: @TemprIncrease - temperature measurement is delayed")
					end
					transition -> TemprIncrease
					event givedelta : human_input?set_delta
					action do
						delta = givedelta.dlta
					end
					transition -> TemprIncrease
					event fetch : human_input?fetch_temp
					action do
						human_output!temperature(thermo_id, "temperature ", lasttemp)
					end
				}
				state TemprDecrease {
					on entry guard_temperature!timer_start(65000)
					on exit guard_temperature!timer_cancel()
					transition -> TemprDecrease
					event temp : get_sensor?temperature
					guard temp.t >= tmrature - delta
					action do
						if (lasttemp < temp.t) request_actuator!SwitchOff(switch_id)
						lasttemp = temp.t
					end
					transition -> TemprIncrease
					event temp2 : get_sensor?temperature
					guard temp2.t < tmrature - delta
					action do
						request_actuator!SwitchOn(switch_id)
						lasttemp = temp2.t
					end
					transition -> TemprDecrease
					event timout : guard_temperature?timer_timeout
					action do
						human_output!prompt("WARNING: @TemprDecrease - temperature measurement is delayed")
					end
					transition -> TemprIncrease
					event givedelta : human_input?set_delta
					action do
						delta = givedelta.dlta
					end
					transition -> TemprIncrease
					event fetch : human_input?fetch_temp
					action do
						human_output!temperature(thermo_id, "temperature ", lasttemp)
					end
				}
				transition -> On
				event swon : human_input?SwitchOn
				action do
					request_actuator!SwitchOn(swon.did)
				end
				transition -> Off
				event swoff : human_input?SwitchOff
				action do
					request_actuator!SwitchOff(swoff.did)
				end
				transition -> Thermostat
				event set_temp : human_input?set_temperature
				action do
					tmrature = set_temp.t
				end
			}
			state On {
				transition -> Off
				event swoff : human_input?SwitchOff
				action do
					request_actuator!SwitchOff(swoff.did)
				end
				transition -> On
				event swon : human_input?SwitchOn
				action do
					request_actuator!SwitchOn(swon.did)
				end
				transition -> Thermostat
				event set_temp : human_input?set_temperature
				action do
					tmrature = set_temp.t
				end
				transition -> On
				event temp : get_sensor?temperature
				action do
					if (lasttemp > temp.t) request_actuator!SwitchOn(switch_id)
					lasttemp = temp.t
				end
			}
			state Off {
				transition -> Off
				event swoff : human_input?SwitchOff
				action do
					request_actuator!SwitchOff(swoff.did)
				end
				transition -> On
				event swon : human_input?SwitchOn
				action do
					request_actuator!SwitchOn(swon.did)
				end
				transition -> Thermostat
				event set_temp : human_input?set_temperature
				action do
					tmrature = set_temp.t
				end
				transition -> Off
				event temp : get_sensor?temperature
				action do
					if (lasttemp < temp.t) request_actuator!SwitchOff(switch_id)
					lasttemp = temp.t
				end
			}
			internal
			event fetch : human_input?fetch_temp
			action do
				human_output!temperature(thermo_id, "temperature ", lasttemp)
			end
			internal
			event get_sensor?iamalive1
			action do
				human_output!prompt("INTERNAL ERROR: iamalive1 received at PIM.Running")
			end
			internal
			event get_sensor?iamalive2
			action do
				human_output!prompt("INTERNAL ERROR: iamalive2 received at PIM.Running")
			end
			transition -> Running
			event givedelta : human_input?set_delta
			action do
				delta = givedelta.dlta
			end
			transition -> Running
			event human_input?SwitchOn
			action do
				human_output!prompt("INTERNAL ERROR: Impossible SwitchOn at PIM.Running")
			end
			transition -> Running
			event human_input?SwitchOff
			action do
				human_output!prompt("INTERNAL ERROR: Impossible SwitchOff at PIM.Running")
			end
			transition -> Running
			event human_input?set_temperature
			action do
				human_output!prompt("INTERNAL ERROR: Impossible set_temperature at PIM.Running")
			end
			transition -> Running
			event temp : get_sensor?temperature
			action do
				human_output!prompt("INTERNAL ERROR: temperature received at PIM.Running")
				lasttemp = temp.t
			end
		}
	}
}
thing MQTTDriver includes TemperatureMsg , OnOffMsg , GeneralMsg , LuminanceMsg {
	provided port require_val {
		receives add_thermometer receives add_device receives add_lightsensor receives SwitchOn receives SwitchOff receives iamalive1 receives iamalive2
	}
	required port provide_temp {
		sends temperature
	}
	required port provide_lum_motion {
		sends luminance
	}
	provided port MQTT {
		sends SwitchOn sends SwitchOff receives temperature receives luminance
	}
	property thermometers : Integer [ 25 ]
	property thermotext : String [ 25 ]
	property thermoval : Double [ 25 ]
	property lightsensors : Integer [ 25 ]
	property lightval : Double [ 25 ]
	property lumval : Double [ 25 ]
	property motionsensors : Integer [ 25 ]
	property last_mo : Integer = 0
	property last_light : Integer = 0
	property last_thermo : Integer = 0
	property last_lum : Integer = 0
	property foundL : Boolean
	property i : Integer
	property id_s : Integer
	property found : Boolean
	property onoffswitches : Integer [ 25 ]
	property last_onoff : Integer = 0
	property did : Integer
	statechart behaviorMQTTDriver init Idle {
		state Idle {
			transition -> Idle
			event put_t : MQTT?temperature
			action do
				id_s = put_t.id
				i = 0
				found = false
				while (i < last_thermo and (not found)) do
					if (id_s == thermometers [i]) do
						found = true
					end
					i = i + 1
				end
				if (found) do
					thermoval[i - 1] = put_t.t
					provide_temp!temperature(id_s, thermotext [i], put_t.t)
				end
			end
			transition -> Idle
			event addt : require_val?add_thermometer
			action do
				id_s = addt.id
				thermometers[last_thermo] = id_s
				thermotext[last_thermo] = addt.txt
				thermoval[last_thermo] = 20
				last_thermo = last_thermo + 1
			end
			transition -> Idle
			event add_dev : require_val?add_device
			action do
				did = add_dev.did
				onoffswitches[last_onoff] = did
				last_onoff = last_onoff + 1
			end
			transition -> Idle
			event swon : require_val?SwitchOn
			action do
				did = swon.did
				i = 0
				found = false
				while (i < last_onoff and (not found)) do
					if (did == onoffswitches [i]) do
						found = true
					end
					i = i + 1
				end
				if (found) do
					MQTT!SwitchOn(did)
				end
			end
			transition -> Idle
			event swoff : require_val?SwitchOff
			action do
				did = swoff.did
				i = 0
				found = false
				while (i < last_onoff and (not found)) do
					if (did == onoffswitches [i]) do
						found = true
					end
					i = i + 1
				end
				if (found) do
					MQTT!SwitchOff(did)
				end
			end
			transition -> Idle
			event addlum : require_val?add_lightsensor
			action do
				id_s = addlum.id
				lightsensors[last_light] = id_s
				lightval[last_light] = 50
				last_light = last_light + 1
			end
			transition -> Idle
			event put_lum : MQTT?luminance
			action do
				id_s = put_lum.id
				i = 0
				foundL = false
				while (i > last_light and (not foundL)) do
					if (id_s == lightsensors [i]) do
						foundL = true
					end
					i = i + 1
				end
				if (foundL) do
					lightval[i - 1] = put_lum.lum
					provide_lum_motion!luminance(id_s, put_lum.lum)
					println ("lum is in psm")
				end
			end
		}
	}
}
thing Human includes TemperatureMsg , GeneralMsg , OnOffMsg , LuminanceMsg @mock "true" {
	required port send_cmd {
		sends SwitchOn sends SwitchOff sends set_luminance sends set_temperature sends set_delta sends fetch_temp
	}
	provided port get_values {
		receives temperature receives prompt
	}
}
thing Simulation includes TemperatureMsg , OnOffMsg , LuminanceMsg , GeneralMsg @mock "true" {
	required port toMQTT {
		sends temperature sends luminance receives SwitchOn receives SwitchOff
	}
}
thing EnergySaver includes TemperatureMsg , LuminanceMsg , GeneralMsg , TimeStuff , TimerMsgs {
	required port send_es_cmd {
		sends set_temperature
	}
	provided port get_es_cmd {
		receives set_temperature receives luminance receives set_luminance
	}
	property comfort_temp : Double
	property lights_off : Double = 2
	property night_temp_delta : Double = 8
	property last_lum : Double
	property lum_threshold : Double
	property isnight : Boolean
	statechart ES_behavior init Build {
		on entry do
			println ("Running Energy Saver (ES)")
			isnight = Night(Now())
			var time_left : Long = 0
			if (isnight) do
				time_left = LeftOfNight()
			end
			else do
				time_left = LeftOfDay()
			end
		end
		composite state Build init setup keeps history {
			state setup {
				internal
				event get_temp : get_es_cmd?set_temperature
				action do
					comfort_temp = get_temp.t
				end
				internal
				event fetch : get_es_cmd?set_luminance
				action do
					lum_threshold = fetch.lum
				end
				internal
				event get_lum : get_es_cmd?luminance
				action do
					last_lum = get_lum.lum
				end
				transition -> night guard isnight and (comfort_temp > 0 and last_lum > 0 and lum_threshold > 0)
				transition -> day guard not isnight and (comfort_temp > 0 and last_lum > 0 and lum_threshold > 0)
			}
			state present {
				on entry println ("People are present")
				internal
				event get_temp : get_es_cmd?set_temperature
				action do
					comfort_temp = get_temp.t
				end
				internal
				event fetch : get_es_cmd?set_luminance
				action do
					lum_threshold = fetch.lum
				end
				internal
				event get_lum : get_es_cmd?luminance
				action do
					last_lum = get_lum.lum
				end
				transition -> night guard isnight and (last_lum <= lum_threshold)
				action do
					send_es_cmd!set_temperature(comfort_temp - night_temp_delta)
					println ("People are not present anymore")
					println ("New temp is " + (comfort_temp - night_temp_delta) + " for night time")
				end
				transition -> day guard not isnight and (last_lum <= lum_threshold)
				action do
					send_es_cmd!set_temperature(comfort_temp - lights_off)
					println ("People are not present anymore")
					println ("New temp is " + (comfort_temp - lights_off) + " for day time")
				end
			}
			state day {
				internal
				event fetch : get_es_cmd?set_luminance
				action do
					lum_threshold = fetch.lum
				end
				internal
				event get_temp : get_es_cmd?set_temperature
				action do
					comfort_temp = get_temp.t
				end
				internal
				event get_lum : get_es_cmd?luminance
				action do
					last_lum = get_lum.lum
				end
				transition -> present guard last_lum > lum_threshold
				action do
					send_es_cmd!set_temperature(comfort_temp)
					println ("New temp is " + (comfort_temp) + " for day time with people present")
				end
				transition -> night guard isnight
				action do
					send_es_cmd!set_temperature(comfort_temp - night_temp_delta)
					println ("New temp is " + (comfort_temp - night_temp_delta) + " for night time")
				end
			}
			state night {
				on entry println ("Initialize Night state")
				internal
				event get_temp : get_es_cmd?set_temperature
				action do
					comfort_temp = get_temp.t
				end
				internal
				event fetch : get_es_cmd?set_luminance
				action do
					lum_threshold = fetch.lum
				end
				internal
				event get_lum : get_es_cmd?luminance
				action do
					last_lum = get_lum.lum
				end
				transition -> day guard not isnight
				action do
					send_es_cmd!set_temperature(comfort_temp - lights_off)
					println ("New temp is " + (comfort_temp - lights_off) + " for day time")
				end
				transition -> present guard last_lum > lum_threshold
				action do
					send_es_cmd!set_temperature(comfort_temp)
					println ("New temp is " + (comfort_temp) + " for night time with people present")
				end
			}
		}
	}
}
datatype Byte<1>
	@type_checker "Integer"
	@c_type "uint8_t"
	@java_type "byte"
	@js_type "byte"
	@go_type "byte"
datatype Char<1>
	@type_checker "Integer"
	@c_type "char"
	@java_type "byte"
	@js_type "byte"
	@go_type "byte"
datatype Boolean<1>
	@type_checker "Boolean"
	@c_type "bool"
	@java_type "boolean"
	@js_type "boolean"
	@go_type "bool"
datatype UInt8<1>
	@type_checker "Integer"
	@c_type "uint8_t"
	@java_type "int"
	@js_type "short"
	@go_type "uint8"
datatype Int8<1>
	@type_checker "Integer"
	@c_type "int8_t"
	@java_type "int"
	@js_type "short"
	@go_type "int8"
datatype UInt16<2>
	@type_checker "Integer"
	@c_type "uint16_t"
	@java_type "int"
	@js_type "int"
	@go_type "uint16"
datatype Int16<2>
	@type_checker "Integer"
	@c_type "int16_t"
	@java_type "int"
	@js_type "short"
	@go_type "int16"
datatype Int32<4>
	@type_checker "Integer"
	@c_type "int32_t"
	@java_type "long"
	@js_type "int"
	@go_type "int32"
datatype UInt32<4>
	@type_checker "Integer"
	@c_type "uint32_t"
	@java_type "long"
	@js_type "long"
	@go_type "uint32"
datatype Long<4>
	@type_checker "Integer"
	@c_type "uint32_t"
	@java_type "long"
	@js_type "long"
	@go_type "uint32"
datatype Int64<8>
	@type_checker "Integer"
	@c_type "int64_t"
	@java_type "long"
	@js_type "long"
	@go_type "int64"
datatype UInt64<8>
	@type_checker "Integer"
	@c_type "uint64_t"
	@java_type "long"
	@js_type "long"
	@go_type "uint64"
datatype Integer<2>
	@type_checker "Integer"
	@c_type "int16_t"
	@java_type "int"
	@js_type "short"
	@go_type "int16"
datatype Float<4>
	@type_checker "Real"
	@c_type "float"
	@java_type "float"
	@js_type "float"
	@go_type "float32"
datatype Double<8>
	@type_checker "Real"
	@c_type "double"
	@java_type "double"
	@js_type "double"
	@go_type "float64"
object String
	@serializable
	@c_type "char *"
	@arduino_type "String"
	@java_type "String"
	@js_type "String"
	@go_type "string"
enumeration DigitalState as UInt8 {
	LOW = 0
	HIGH = 1
}
thing fragment GeneralMsg {
	message iamalive1()
	message iamalive2()
	message prompt(txt : String)
}
thing fragment TemperatureMsg {
	message temperature(id : Integer, txt : String, t : Double)
	message add_thermometer(id : Integer, txt : String)
	message set_temperature(t : Double)
	message set_delta(dlta : Double)
	message fetch_temp()
}
thing fragment LuminanceMsg {
	message luminance(id : Integer, lum : Double)
	message add_lightsensor(id : Integer)
	message set_luminance(lum : Double)
}
thing fragment MotionMsg {
	message motion(id : Integer)
	message nomotion(id : Integer)
	message add_motionsensor(id : Integer)
}
thing fragment DeviceGeneral {
	message add_device(did : Integer)
}
thing fragment OnOffMsg includes DeviceGeneral {
	message SwitchOn(did : Integer)
	message SwitchOff(did : Integer)
}
thing fragment TimeStuff @java_import "import java.time.LocalTime;" {
	property night_start : Long = 23 * 60 * 60 * 1000
	property night_end : Long = 7 * 60 * 60 * 1000
	function Now() : Long do
		var timeval : Long
		timeval = `LocalTime.now().toNanoOfDay()/1000000`
		return timeval
	end
	function Timestamp(h : Integer, m : Integer, s : Integer) : Long do
		return (s + m * 60 + h * 60 * 60) * 1000
	end
	function LeftOfDay() : Long do
		var n : Long = Now()
		var left : Long = night_start - n
		if (left < 0) left = left + 24 * 60 * 60 * 1000
		if (not Night(n)) return left
		else return 0
	end
	function LeftOfNight() : Long do
		var n : Long = Now()
		var left : Long = night_end - n
		if (left < 0) left = left + 24 * 60 * 60 * 1000
		if (Night(n)) return left
		else return 0
	end
	function Night(x : Long) : Boolean do
		if (night_end < night_start) do
			if (night_start <= x or x < night_end) return true
			else return false
		end
		else do
			if (night_start <= x and x < night_end) return true
			else return false
		end
	end
}
configuration X3D_MQTT_SIM {
	instance T1 : MQTTDriver
	instance pim : PIM
	instance myself : Human
	instance g_temp : TimerJava
	instance g_humn : TimerJava
	instance es : EnergySaver
	instance sim : Simulation
	connector T1.provide_temp => pim . get_sensor
	connector T1.provide_lum_motion => es . get_es_cmd
	connector sim.toMQTT => T1 . MQTT
	connector sim.toMQTT => es . get_es_cmd
	connector myself.send_cmd => pim . human_input
	connector myself.send_cmd => es . get_es_cmd
	connector es.send_es_cmd => pim . human_input
	connector pim.request_sensor => T1 . require_val
	connector pim.request_actuator => T1 . require_val
	connector pim.human_output => myself . get_values
	connector pim.guard_temperature => g_temp . timer
	connector pim.guard_human => g_humn . timer
}
