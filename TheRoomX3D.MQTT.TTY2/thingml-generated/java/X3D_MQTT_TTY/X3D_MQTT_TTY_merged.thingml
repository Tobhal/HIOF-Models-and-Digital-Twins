thing MQTTDriver includes TemperatureMsg , OnOffMsg , GeneralMsg {
	required port provide_temp {
		sends temperature sends iamalive1 sends iamalive2
	}
	provided port require_val {
		receives add_thermometer receives add_device receives SwitchOn receives SwitchOff receives iamalive1 receives iamalive2
	}
	provided port MQTT {
		sends SwitchOn sends SwitchOff receives temperature
	}
	property thermometers : Integer [ 25 ]
	property thermotext : String [ 25 ]
	property thermoval : Double [ 25 ]
	property lightsensors : Integer [ 25 ]
	property lightval : Double [ 25 ]
	property motionsensors : Integer [ 25 ]
	property last_mo : Integer = 0
	property last_light : Integer = 0
	property last_thermo : Integer = 0
	property foundL : Boolean
	property i : Integer
	property id_s : Integer
	property found : Boolean
	property onoffswitches : Integer [ 25 ]
	property last_onoff : Integer = 0
	property did : Integer
	statechart behaviorMQTTDriver init Alive1 {
		state Alive1 {
			on entry do
				provide_temp!iamalive1()
			end
			transition -> Alive2
			event alv : require_val?iamalive1
			action do
				provide_temp!iamalive2()
			end
			transition -> Idle
			event alv : require_val?iamalive2
			action do
				provide_temp!iamalive2()
			end
		}
		state Alive2 {
			transition -> Idle
			event alv : require_val?iamalive2
		}
		state Idle {
			transition -> Idle
			event put_t : MQTT?temperature
			action do
				id_s = put_t.id
				i = 0
				found = false
				while (i < last_thermo and (not found)) do
					if (id_s == thermometers [i]) do
						found = true
					end
					i = i + 1
				end
				if (found) do
					thermoval[i - 1] = put_t.t
					provide_temp!temperature(id_s, thermotext [i], put_t.t)
				end
			end
			transition -> Idle
			event addt : require_val?add_thermometer
			action do
				id_s = addt.id
				thermometers[last_thermo] = id_s
				thermotext[last_thermo] = addt.txt
				thermoval[last_thermo] = 20
				last_thermo = last_thermo + 1
			end
			transition -> Idle
			event add_dev : require_val?add_device
			action do
				did = add_dev.did
				onoffswitches[last_onoff] = did
				last_onoff = last_onoff + 1
			end
			transition -> Idle
			event swon : require_val?SwitchOn
			action do
				did = swon.did
				i = 0
				found = false
				while (i < last_onoff and (not found)) do
					if (did == onoffswitches [i]) do
						found = true
					end
					i = i + 1
				end
				if (found) do
					MQTT!SwitchOn(did)
				end
			end
			transition -> Idle
			event swoff : require_val?SwitchOff
			action do
				did = swoff.did
				i = 0
				found = false
				while (i < last_onoff and (not found)) do
					if (did == onoffswitches [i]) do
						found = true
					end
					i = i + 1
				end
				if (found) do
					MQTT!SwitchOff(did)
				end
			end
		}
	}
}
thing PIM includes GeneralMsg , TemperatureMsg , OnOffMsg , TimerMsgs {
	provided port get_sensor {
		receives iamalive1 receives iamalive2 receives temperature
	}
	required port request_sensor {
		sends iamalive1 sends iamalive2 sends add_thermometer
	}
	required port request_actuator {
		sends add_device sends SwitchOn sends SwitchOff
	}
	provided port human_input {
		receives SwitchOn receives SwitchOff receives set_temperature receives set_delta receives fetch_temp
	}
	required port human_output {
		sends temperature sends prompt
	}
	required port guard_temperature {
		sends timer_start sends timer_cancel receives timer_timeout
	}
	required port guard_human {
		sends timer_start sends timer_cancel receives timer_timeout
	}
	property tmrature : Double = 20
	property thermo_id : Integer = 1
	property switch_id : Integer = 1
	property delta : Double = 0.1
	property lasttemp : Double = 0
	statechart PIM_behavior init Build {
		on entry do
			print ("Running The Room X3D.MQTT.TTY\n")
		end
		composite state Build init Alive1 keeps history {
			on entry guard_human!timer_start(30000)
			on exit guard_human!timer_cancel()
			state Alive1 {
				on entry do
					request_sensor!iamalive1()
				end
				transition -> Alive2
				event alv : get_sensor?iamalive1
				action do
					request_sensor!iamalive2()
				end
				transition -> SetThermostat
				event alv : get_sensor?iamalive2
				action do
					request_sensor!iamalive2()
				end
			}
			state Alive2 {
				transition -> SetThermostat
				event alv : get_sensor?iamalive2
			}
			state SetThermostat {
				on entry do
					request_sensor!add_thermometer(thermo_id, "t")
					request_actuator!add_device(switch_id)
				end
				transition -> SetThermostat
				event human_input?SwitchOn
				action do
					human_output!prompt("Please set temperature for Thermostat")
				end
				transition -> SetThermostat
				event human_input?SwitchOff
				action do
					human_output!prompt("Please set temperature for Thermostat")
				end
			}
			internal
			event givedelta : human_input?set_delta
			action do
				delta = givedelta.dlta
			end
			internal
			event fetch : human_input?fetch_temp
			action do
				human_output!temperature(thermo_id, "temperature ", lasttemp)
			end
			internal
			event temp : get_sensor?temperature
			action do
				lasttemp = temp.t
			end
			internal
			event get_sensor?iamalive1
			action do
				human_output!prompt("INTERNAL ERROR: iamalive1 is covered inside Build")
			end
			internal
			event get_sensor?iamalive2
			action do
				human_output!prompt("INTERNAL ERROR: iamalive2 is covered inside Build")
			end
			transition -> Running
			event set_temp : human_input?set_temperature
			action do
				tmrature = set_temp.t
				human_output!prompt("Now entering thermostat. Please give temperature observations")
			end
			transition -> Build
			event tmout : guard_human?timer_timeout
			action do
				human_output!prompt("Please continue doing the build of the temperature control")
			end
		}
		composite state Running init Thermostat keeps history {
			composite state Thermostat init TemprDecide {
				state TemprDecide {
					transition -> TemprDecrease guard lasttemp >= tmrature - delta
					action do
						request_actuator!SwitchOff(switch_id)
					end
					transition -> TemprIncrease guard lasttemp < tmrature - delta
					action do
						request_actuator!SwitchOn(switch_id)
					end
				}
				state TemprIncrease {
					on entry guard_temperature!timer_start(65000)
					on exit guard_temperature!timer_cancel()
					transition -> TemprIncrease
					event temp : get_sensor?temperature
					guard temp.t <= tmrature + delta
					action do
						if (lasttemp > temp.t) request_actuator!SwitchOn(switch_id)
						lasttemp = temp.t
					end
					transition -> TemprDecrease
					event temp2 : get_sensor?temperature
					guard temp2.t > tmrature + delta
					action do
						request_actuator!SwitchOff(switch_id)
						lasttemp = temp2.t
					end
					transition -> TemprIncrease
					event timout : guard_temperature?timer_timeout
					action do
						human_output!prompt("WARNING: @TemprIncrease - temperature measurement is delayed")
					end
					transition -> TemprIncrease
					event givedelta : human_input?set_delta
					action do
						delta = givedelta.dlta
					end
					transition -> TemprIncrease
					event fetch : human_input?fetch_temp
					action do
						human_output!temperature(thermo_id, "temperature ", lasttemp)
					end
				}
				state TemprDecrease {
					on entry guard_temperature!timer_start(65000)
					on exit guard_temperature!timer_cancel()
					transition -> TemprDecrease
					event temp : get_sensor?temperature
					guard temp.t >= tmrature - delta
					action do
						if (lasttemp < temp.t) request_actuator!SwitchOff(switch_id)
						lasttemp = temp.t
					end
					transition -> TemprIncrease
					event temp2 : get_sensor?temperature
					guard temp2.t < tmrature - delta
					action do
						request_actuator!SwitchOn(switch_id)
						lasttemp = temp2.t
					end
					transition -> TemprDecrease
					event timout : guard_temperature?timer_timeout
					action do
						human_output!prompt("WARNING: @TemprDecrease - temperature measurement is delayed")
					end
					transition -> TemprIncrease
					event givedelta : human_input?set_delta
					action do
						delta = givedelta.dlta
					end
					transition -> TemprIncrease
					event fetch : human_input?fetch_temp
					action do
						human_output!temperature(thermo_id, "temperature ", lasttemp)
					end
				}
				transition -> On
				event swon : human_input?SwitchOn
				action do
					request_actuator!SwitchOn(swon.did)
				end
				transition -> Off
				event swoff : human_input?SwitchOff
				action do
					request_actuator!SwitchOff(swoff.did)
				end
				transition -> Thermostat
				event set_temp : human_input?set_temperature
				action do
					tmrature = set_temp.t
				end
			}
			state On {
				transition -> Off
				event swoff : human_input?SwitchOff
				action do
					request_actuator!SwitchOff(swoff.did)
				end
				transition -> On
				event swon : human_input?SwitchOn
				action do
					request_actuator!SwitchOn(swon.did)
				end
				transition -> Thermostat
				event set_temp : human_input?set_temperature
				action do
					tmrature = set_temp.t
				end
				transition -> On
				event temp : get_sensor?temperature
				action do
					if (lasttemp > temp.t) request_actuator!SwitchOn(switch_id)
					lasttemp = temp.t
				end
			}
			state Off {
				transition -> Off
				event swoff : human_input?SwitchOff
				action do
					request_actuator!SwitchOff(swoff.did)
				end
				transition -> On
				event swon : human_input?SwitchOn
				action do
					request_actuator!SwitchOn(swon.did)
				end
				transition -> Thermostat
				event set_temp : human_input?set_temperature
				action do
					tmrature = set_temp.t
				end
				transition -> Off
				event temp : get_sensor?temperature
				action do
					if (lasttemp < temp.t) request_actuator!SwitchOff(switch_id)
					lasttemp = temp.t
				end
			}
			internal
			event get_sensor?iamalive1
			action do
				human_output!prompt("INTERNAL ERROR: iamalive1 received at PIM.Running")
			end
			internal
			event get_sensor?iamalive2
			action do
				human_output!prompt("INTERNAL ERROR: iamalive2 received at PIM.Running")
			end
			transition -> Running
			event givedelta : human_input?set_delta
			action do
				delta = givedelta.dlta
			end
			transition -> Running
			event fetch : human_input?fetch_temp
			action do
				human_output!temperature(thermo_id, "temperature ", lasttemp)
			end
			transition -> Running
			event human_input?SwitchOn
			action do
				human_output!prompt("INTERNAL ERROR: Impossible SwitchOn at PIM.Running")
			end
			transition -> Running
			event human_input?SwitchOff
			action do
				human_output!prompt("INTERNAL ERROR: Impossible SwitchOff at PIM.Running")
			end
			transition -> Running
			event human_input?set_temperature
			action do
				human_output!prompt("INTERNAL ERROR: Impossible set_temperature at PIM.Running")
			end
			transition -> Running
			event temp : get_sensor?temperature
			action do
				human_output!prompt("INTERNAL ERROR: temperature received at PIM.Running")
				lasttemp = temp.t
			end
		}
	}
}
thing Human includes TemperatureMsg , GeneralMsg , OnOffMsg , DeviceGeneral {
	required port send_cmd_temp {
		sends SwitchOn sends SwitchOff sends set_temperature sends set_delta sends fetch_temp
	}
	provided port TTYin_temp {
		receives SwitchOn receives SwitchOff receives set_temperature receives set_delta receives fetch_temp
	}
	required port get_values {
		sends temperature sends prompt
	}
	provided port TTYout {
		receives temperature receives prompt
	}
	statechart HumanBehavior init Idle {
		state Idle {
			transition -> Idle
			event son : TTYin_temp?SwitchOn
			action send_cmd_temp!SwitchOn(son.did)
			transition -> Idle
			event sof : TTYin_temp?SwitchOff
			action send_cmd_temp!SwitchOff(sof.did)
			transition -> Idle
			event st : TTYin_temp?set_temperature
			action send_cmd_temp!set_temperature(st.t)
			transition -> Idle
			event sd : TTYin_temp?set_delta
			action send_cmd_temp!set_delta(sd.dlta)
			transition -> Idle
			event st : TTYin_temp?fetch_temp
			action send_cmd_temp!fetch_temp()
			transition -> Idle
			event tp : TTYout?temperature
			action do
				get_values!temperature(tp.id, tp.txt, tp.t)
			end
			transition -> Idle
			event prm : TTYout?prompt
			action do
				println prm.txt
			end
		}
	}
}
object JTimerTask @java_type "java.util.TimerTask"
object JTimer @java_type "java.util.Timer"
thing TimerJava includes Timer @pim "Timer" @platform "java" {
	property timer : JTimer
	property timer_task : JTimerTask
	function startTimer(delay : Integer) do
		timer = `new java.util.Timer()`
	`java.util.TimerTask temp_task = new java.util.TimerTask(){public void run(){`
		timer!timer_timeout()
	`}};`
		timer_task = `temp_task`
		`` & timer & `.schedule(` & timer_task & `, ` & delay & `);`
	end
	function cancel() do
		if (not (timer_task == `null`)) do
			`` & timer_task & `.cancel();`
			`` & timer & `.purge();`
		end
	end
	statechart SoftTimer init default {
		state default {
			internal
			event m : timer?timer_start
			guard m.delay > 0
			action do
				startTimer(m.delay)
			end
			internal cancel
			event m : timer?timer_cancel
			action cancel()
		}
	}
}
datatype Byte<1>
	@type_checker "Integer"
	@c_type "uint8_t"
	@java_type "byte"
	@js_type "byte"
	@go_type "byte"
datatype Char<1>
	@type_checker "Integer"
	@c_type "char"
	@java_type "byte"
	@js_type "byte"
	@go_type "byte"
datatype Boolean<1>
	@type_checker "Boolean"
	@c_type "bool"
	@java_type "boolean"
	@js_type "boolean"
	@go_type "bool"
datatype UInt8<1>
	@type_checker "Integer"
	@c_type "uint8_t"
	@java_type "int"
	@js_type "short"
	@go_type "uint8"
datatype Int8<1>
	@type_checker "Integer"
	@c_type "int8_t"
	@java_type "int"
	@js_type "short"
	@go_type "int8"
datatype UInt16<2>
	@type_checker "Integer"
	@c_type "uint16_t"
	@java_type "int"
	@js_type "int"
	@go_type "uint16"
datatype Int16<2>
	@type_checker "Integer"
	@c_type "int16_t"
	@java_type "int"
	@js_type "short"
	@go_type "int16"
datatype Int32<4>
	@type_checker "Integer"
	@c_type "int32_t"
	@java_type "long"
	@js_type "int"
	@go_type "int32"
datatype UInt32<4>
	@type_checker "Integer"
	@c_type "uint32_t"
	@java_type "long"
	@js_type "long"
	@go_type "uint32"
datatype Long<4>
	@type_checker "Integer"
	@c_type "uint32_t"
	@java_type "long"
	@js_type "long"
	@go_type "uint32"
datatype Int64<8>
	@type_checker "Integer"
	@c_type "int64_t"
	@java_type "long"
	@js_type "long"
	@go_type "int64"
datatype UInt64<8>
	@type_checker "Integer"
	@c_type "uint64_t"
	@java_type "long"
	@js_type "long"
	@go_type "uint64"
datatype Integer<2>
	@type_checker "Integer"
	@c_type "int16_t"
	@java_type "int"
	@js_type "short"
	@go_type "int16"
datatype Float<4>
	@type_checker "Real"
	@c_type "float"
	@java_type "float"
	@js_type "float"
	@go_type "float32"
datatype Double<8>
	@type_checker "Real"
	@c_type "double"
	@java_type "double"
	@js_type "double"
	@go_type "float64"
object String
	@serializable
	@c_type "char *"
	@arduino_type "String"
	@java_type "String"
	@js_type "String"
	@go_type "string"
enumeration DigitalState as UInt8 {
	LOW = 0
	HIGH = 1
}
thing fragment GeneralMsg {
	message iamalive1()
	message iamalive2()
	message prompt(txt : String)
}
thing fragment TemperatureMsg {
	message temperature(id : Integer, txt : String, t : Double)
	message add_thermometer(id : Integer, txt : String)
	message set_temperature(t : Double)
	message set_delta(dlta : Double)
	message fetch_temp()
}
thing fragment LuminanceMsg {
	message luminance(id : Integer, lum : Double)
	message add_lightsensor(id : Integer)
	message set_luminance(lum : Double)
}
thing fragment MotionMsg {
	message motion(id : Integer)
	message nomotion(id : Integer)
	message add_motionsensor(id : Integer)
}
thing fragment DeviceGeneral {
	message add_device(did : Integer)
}
thing fragment OnOffMsg includes DeviceGeneral {
	message SwitchOn(did : Integer)
	message SwitchOff(did : Integer)
}
thing fragment TimerMsgs {
	message timer_start(delay : Integer)
	message timer_cancel()
	@debug "false"
	message timer_timeout()
}
thing fragment Timer includes TimerMsgs {
	provided port timer {
		sends timer_timeout receives timer_start receives timer_cancel
	}
}
thing fragment TimerClient includes TimerMsgs {
	required port timer {
		sends timer_start sends timer_cancel receives timer_timeout
	}
}
thing TimerClientMock includes TimerClient @mock "true" {
}
protocol MQTT
	@serializer "JSON"
	@mqtt_broker_address "localhost"
	@mqtt_broker_port "1883"
	@mqtt_publish_topic "CPS2021/SwitchControl"
	@mqtt_subscribe_topic "CPS2021/tempoutput"

protocol stdio @serializer "JSON"

configuration X3D_MQTT_TTY {
	instance T1 : MQTTDriver
	instance pim : PIM
	instance myself : Human
	instance g_temp : TimerJava
	instance g_humn : TimerJava
	connector T1.provide_temp => pim . get_sensor
	connector myself.send_cmd_temp => pim . human_input
	connector pim.request_sensor => T1 . require_val
	connector pim.request_actuator => T1 . require_val
	connector pim.human_output => myself . TTYout
	connector pim.guard_temperature => g_temp . timer
	connector pim.guard_human => g_humn . timer
	connector myself.get_values over stdio
	connector myself.TTYin_temp over stdio
	connector T1.MQTT over MQTT
}
